阶段一：核心游戏状态与知识图谱管理
设计并实现游戏状态管理器 (game_state_manager.py):
定义需要跟踪的游戏状态数据结构（玩家位置、属性、物品、任务、NPC状态、当前回合、上次描述等）。
关键： 实现状态的持久化存储（如JSON文件、SQLite数据库、Redis），需要能区分不同用户或不同群聊的游戏实例（使用QQ号或群号作为Key）。
实现加载、保存、获取和更新特定用户/群聊游戏状态的函数。
构建或集成知识图谱管理器 (knowledge_graph_manager.py):
选择知识图谱的存储方式（如 networkx 导出/导入文件，或连接到图数据库）。
预先填充基础的世界设定、地点、NPC、物品等核心信息。
实现查询知识图谱的函数（根据关键词或结构化查询返回相关信息）。
通常核心设定是全局的，动态发现可以是实例相关的

阶段二：整合LLM进行叙事与交互 通过langbot接口实现
在消息处理器中集成LLM调用:
当收到玩家的游戏指令（如“向北走”、“和村民说话”）时：
加载当前用户/群聊的游戏状态。
根据指令和状态查询知识图谱，获取相关背景信息。
构建Prompt: 精心设计发送给LLM API的Prompt。需要包含：
角色扮演指示（“你是一个TRPG主持人…”）。
当前游戏状态摘要。
相关的知识图谱信息。
玩家的输入指令。
期望的输出格式（如JSON，包含叙述文本、图片生成提示词、3个选项、可选的状态更新建议）。
调用LLM API: 使用requests或官方SDK调用你选择的LLM（GPT、Claude等）的API。处理认证和错误。
解析LLM响应: 从返回的JSON中提取叙述、图片提示、选项等。
处理LLM的响应:
更新游戏状态:
将LLM生成的叙述保存到游戏状态（作为“上次描述”）。
将LLM生成的选项保存，用于下次展示给玩家。
谨慎处理状态更新建议： 如果LLM建议了状态变更（如state_updates），需要验证并应用到GameStateManager。不要无条件信任LLM的更新指令，要有校验逻辑。
更新回合数等。
保存状态: 触发游戏状态的保存。

阶段三：实现视觉元素（图片与地图）
集成图片生成 (image_generator.py):
实现调用图片生成模型API（DALL-E, Stable Diffusion等）的函数。输入是LLM生成的图片提示词。
函数应能处理API调用、获取图片URL或数据，并将图片下载保存到本地临时文件。
实现地图绘制 (map_drawer.py):
实现使用代码（如matplotlib）根据游戏状态（玩家坐标、地图数据）绘制地图的功能。
函数需要将绘制的地图保存为本地图片文件。
决策： 地图数据如何存储在游戏状态中？（简单的二维数组？更复杂的对象描述？）。何时触发地图重绘？（每次移动？进入新区域？）。
在消息处理器中整合视觉输出:
在收到LLM响应后，如果包含有效的图片提示词，则调用图片生成函数。
根据游戏逻辑（如玩家移动、查看地图指令），调用地图绘制函数。
获取生成的图片文件路径。

程序状态
进入跑团状态后 默认消息接口关闭，全部由插件处理消息


响应流程
跑团状态未开启前
收到跑团指令进入列表选择 （新跑团，加入已有的跑团）
进入新跑团或加入已有的跑团后 进入跑团模式 此时所有模型请求由插件接管
当收到玩家的游戏指令时：
Langbot事件监听器接收到事件
将消息转发给LLM
LLM查询知识图谱获得当前游戏状态，并做出回应
将回应通过langbot消息事件从qq发出
根据LLM接受和输出的信息更新知识图谱




功能实现：
使用langbot 接口实现收发消息 
1.消息接收
实现流程  接受到消息  将消息封装给对象 
2.消息发送
制作游戏状态管理器


角色管理器
1.定义角色属性 属性分为系统属性（对局中不可修改，只可由系统修改 如职业，状态值）和玩家属性（对局中可修改（不在自己的回合也可修改） 如携带的装备）
现在的想法是将定义属性留给剧本，这样可以防止出现过多多余属性
这样角色管理器需要实现
1.初始化剧本中的角色属性
2.创建 编辑 删除功能 
3.分成两个个状态 创建  游玩中   游玩中不允许编辑角色系统属性但可编辑装备之类的玩家属性
创建角色流程：
报名成果后bot会私聊报名者
进行职业选择和属性点分配
可进行随机，选择随机则由ai根据剧本中的角色创建模板创建角色
若自行选择，流程为
bot输入“请输入你想创建的角色信息” #问题 职业由玩家决定还是由剧本决定
玩家输入 想创建的角色的描述 



知识图谱实现LLM长期记忆
使用坐标绘制地图

个人游戏总计or成就 