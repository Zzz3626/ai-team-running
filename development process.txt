阶段一：核心游戏状态与知识图谱管理
设计并实现游戏状态管理器 (game_state_manager.py):
定义需要跟踪的游戏状态数据结构（玩家位置、属性、物品、任务、NPC状态、当前回合、上次描述等）。
关键： 实现状态的持久化存储（如JSON文件、SQLite数据库、Redis），需要能区分不同用户或不同群聊的游戏实例（使用QQ号或群号作为Key）。
实现加载、保存、获取和更新特定用户/群聊游戏状态的函数。
构建或集成知识图谱管理器 (knowledge_graph_manager.py):
选择知识图谱的存储方式（如 networkx 导出/导入文件，或连接到图数据库）。
预先填充基础的世界设定、地点、NPC、物品等核心信息。
实现查询知识图谱的函数（根据关键词或结构化查询返回相关信息）。
通常核心设定是全局的，动态发现可以是实例相关的

阶段二：整合LLM进行叙事与交互
在消息处理器中集成LLM调用:
当收到玩家的游戏指令（如“向北走”、“和村民说话”）时：
加载当前用户/群聊的游戏状态。
根据指令和状态查询知识图谱，获取相关背景信息。
构建Prompt: 精心设计发送给LLM API的Prompt。需要包含：
角色扮演指示（“你是一个TRPG主持人…”）。
当前游戏状态摘要。
相关的知识图谱信息。
玩家的输入指令。
期望的输出格式（如JSON，包含叙述文本、图片生成提示词、3个选项、可选的状态更新建议）。
调用LLM API: 使用requests或官方SDK调用你选择的LLM（GPT、Claude等）的API。处理认证和错误。
解析LLM响应: 从返回的JSON中提取叙述、图片提示、选项等。
处理LLM的响应:
更新游戏状态:
将LLM生成的叙述保存到游戏状态（作为“上次描述”）。
将LLM生成的选项保存，用于下次展示给玩家。
谨慎处理状态更新建议： 如果LLM建议了状态变更（如state_updates），需要验证并应用到GameStateManager。不要无条件信任LLM的更新指令，要有校验逻辑。
更新回合数等。
保存状态: 触发游戏状态的保存。

阶段三：实现视觉元素（图片与地图）
集成图片生成 (image_generator.py):
实现调用图片生成模型API（DALL-E, Stable Diffusion等）的函数。输入是LLM生成的图片提示词。
函数应能处理API调用、获取图片URL或数据，并将图片下载保存到本地临时文件。
实现地图绘制 (map_drawer.py):
实现使用代码（如matplotlib）根据游戏状态（玩家坐标、地图数据）绘制地图的功能。
函数需要将绘制的地图保存为本地图片文件。
决策： 地图数据如何存储在游戏状态中？（简单的二维数组？更复杂的对象描述？）。何时触发地图重绘？（每次移动？进入新区域？）。
在消息处理器中整合视觉输出:
在收到LLM响应后，如果包含有效的图片提示词，则调用图片生成函数。
根据游戏逻辑（如玩家移动、查看地图指令），调用地图绘制函数。
获取生成的图片文件路径。